; Bin zu Hex Turing-Maschine
; Geschrieben für den Turing-Maschinen-Simulator auf ***REMOVED***
; Erwartet binäre Eingabe rechts des Cursors, mit Leerzeichen in 4-bit-Abschnitte getrennt.
; geschrieben von ea-ooe

0 * * r init

; Ich suche das rechte Ende des Inputs
init 0 * r init
init 1 * r init
init _ * l go

; Ich stelle die Erste Binärziffer fest, und setze dementsprechend fort, bis ich in einem 4-stelligen Zustand bin
go 0 * l zero
go 1 * l 1

zero 0 * l 00
zero 1 * l 10

1 0 * l 01
1 1 * l 11

00 0 * l 000
00 1 * l 100

01 0 * l 001
01 1 * l 101

10 0 * l 010
10 1 * l 110

11 0 * l 011
11 1 * l 111

000 0 * * 0000
000 1 * * 1000

001 0 * * 0001
001 1 * * 1001

010 0 * * 0010
010 1 * * 1010

011 0 * * 0011
011 1 * * 1011

100 0 * * 0100
100 1 * * 1100

101 0 * * 0101
101 1 * * 1101

110 0 * * 0110
110 1 * * 1110

111 0 * * 0111
111 1 * * 1111

; Ich schreibe das dieser 4-Bit-Zahl entsprechende zeichen dahinter, und starte die Suche nach mehr input.
0000 0 * r 0000
0000 1 * r 0000
0000 _ O r again

0001 0 * r 0001
0001 1 * r 0001
0001 _ I r again

0010 0 * r 0010
0010 1 * r 0010
0010 _ 2 r again

0011 0 * r 0011
0011 1 * r 0011
0011 _ 3 r again

0100 0 * r 0100
0100 1 * r 0100
0100 _ 4 r again

0101 0 * r 0101
0101 1 * r 0101
0101 _ 5 r again 

0110 0 * r 0110
0110 1 * r 0110
0110 _ 6 r again 

0111 0 * r 0111
0111 1 * r 0111
0111 _ 7 r again

1000 0 * r 1000
1000 1 * r 1000
1000 _ 8 r again

1001 0 * r 1001
1001 1 * r 1001
1001 _ 9 r again

1010 0 * r 1010
1010 1 * r 1010
1010 _ A r again

1011 0 * r 1011
1011 1 * r 1011
1011 _ B r again

1100 0 * r 1100
1100 1 * r 1100
1100 _ C r again

1101 0 * r 1101
1101 1 * r 1101
1101 _ D r again

1110 0 * r 1110
1110 1 * r 1110
1110 _ E r again

1111 0 * r 1111
1111 1 * r 1111
1111 _ F r again

; Wenn wir mehr Input finden, bearbeiten wir es erneut, wie von vorne. Wenn nicht, bereiten den Putzprozess vor, der Nullen und Einsen durch Leerzeichen ersetzt.
again _ * l cleaninit
again 0 * * init
again 1 * * init

; Wir suchen das linke Ende des Inputs, und beginnen den Putzprozess.
cleaninit _ * r clean
cleaninit * * l cleaninit

; Wir ersetzen alle Nullen und Einsen durch Leerzeichen, lassen unser Arbeitsergebnis heil, und bereiten den Aufräumprozess vor, der unser Output zusammenzieht.
clean 0 _ r clean
clean 1 _ r clean
clean _ * * tidyinit
clean * * r clean

; Wir setzen einen Input-Output-Trenner (/) und suchen den Anfang unseres Outputs. Wenn wir 4 Zeichen lang nur Leerzeichen finden sind wir am Ende angelangt, und können das nächste Zeichen zum verschieben suchen.
tidyinit _ / l tidyinit2

tidyinit2 _ * l tidyinit22
tidyinit2 * * l tidyinit2

tidyinit22 _ * l tidyinit23

tidyinit23 _ * l tidyinit24

tidyinit24 _ * l tidyinit25

tidyinit25 _ * r tidysearch
tidyinit25 * * l tidyinit2

; Wir suchen uns ein Zeichen, das wir hinter das (/) verschieben möchten.
tidysearch _ * r tidysearch
tidysearch O _ r tidyreturn0
tidysearch I _ r tidyreturn1
tidysearch 2 _ r tidyreturn2
tidysearch 3 _ r tidyreturn3
tidysearch 4 _ r tidyreturn4
tidysearch 5 _ r tidyreturn5
tidysearch 6 _ r tidyreturn6
tidysearch 7 _ r tidyreturn7
tidysearch 8 _ r tidyreturn8
tidysearch 9 _ r tidyreturn9
tidysearch A _ r tidyreturnA
tidysearch B _ r tidyreturnB
tidysearch C _ r tidyreturnC
tidysearch D _ r tidyreturnD
tidysearch E _ r tidyreturnE
tidysearch F _ r tidyreturnF
tidysearch / _ r goright

; Wir suchen den (/) um erst dahinter unser Zeichen zu platzieren.
tidyreturn0 / * r tidyput0
tidyreturn0 * * r tidyreturn0

tidyreturn1 / * r tidyput1
tidyreturn1 * * r tidyreturn1

tidyreturn2 / * r tidyput2
tidyreturn2 * * r tidyreturn2

tidyreturn3 / * r tidyput3
tidyreturn3 * * r tidyreturn3

tidyreturn4 / * r tidyput4
tidyreturn4 * * r tidyreturn4

tidyreturn5 / * r tidyput5
tidyreturn5 * * r tidyreturn5

tidyreturn6 / * r tidyput6
tidyreturn6 * * r tidyreturn6

tidyreturn7 / * r tidyput7
tidyreturn7 * * r tidyreturn7

tidyreturn8 / * r tidyput8
tidyreturn8 * * r tidyreturn8

tidyreturn9 / * r tidyput9
tidyreturn9 * * r tidyreturn9

tidyreturnA / * r tidyputA
tidyreturnA * * r tidyreturnA

tidyreturnB / * r tidyputB
tidyreturnB * * r tidyreturnB

tidyreturnC / * r tidyputC
tidyreturnC * * r tidyreturnC

tidyreturnD / * r tidyputD
tidyreturnD * * r tidyreturnD

tidyreturnE / * r tidyputE
tidyreturnE * * r tidyreturnE

tidyreturnF / * r tidyputF
tidyreturnF * * r tidyreturnF

; Wir suchen das Ende des bisherigen Outputs und platzieren dort unser Zeichen. Anschließend suchen wir das nächste.
tidyput0 _ 0 l tidysearchagain
tidyput0 * * r tidyput0

tidyput1 _ 1 l tidysearchagain
tidyput1 * * r tidyput1

tidyput2 _ 2 l tidysearchagain
tidyput2 * * r tidyput2

tidyput3 _ 3 l tidysearchagain
tidyput3 * * r tidyput3

tidyput4 _ 4 l tidysearchagain
tidyput4 * * r tidyput4

tidyput5 _ 5 l tidysearchagain
tidyput5 * * r tidyput5

tidyput6 _ 6 l tidysearchagain
tidyput6 * * r tidyput6

tidyput7 _ 7 l tidysearchagain
tidyput7 * * r tidyput7

tidyput8 _ 8 l tidysearchagain
tidyput8 * * r tidyput8

tidyput9 _ 9 l tidysearchagain
tidyput9 * * r tidyput9

tidyputA _ A l tidysearchagain
tidyputA * * r tidyputA

tidyputB _ B l tidysearchagain
tidyputB * * r tidyputB

tidyputC _ C l tidysearchagain
tidyputC * * r tidyputC

tidyputD _ D l tidysearchagain
tidyputD * * r tidyputD

tidyputE _ E l tidysearchagain
tidyputE * * r tidyputE

tidyputF _ F l tidysearchagain
tidyputF * * r tidyputF

; Wir beginnen unsere Suche nach dem neuen linken Ende des Outputs, um dort unser nächstes Zeichen zu finden.
tidysearchagain / * l tidyinit2
tidysearchagain * * l tidysearchagain

; Wir positionieren den Cursor hinter dem Output und beenden.
goright _ ¶ * asciiinit
goright * * r goright

asciiinit _ * r asciireadONE
asciiinit * * l asciiinit

asciireadONE 2 _ r asciireadTWO2
asciireadONE 3 _ r asciireadTWO3
asciireadONE 4 _ r asciireadTWO4
asciireadONE 5 _ r asciireadTWO5
asciireadONE 6 _ r asciireadTWO6
asciireadONE 7 _ r asciireadTWO7

asciireadTWO2 0 _ r asciiwritespace
asciireadTWO2 1 _ r asciiwrite!
asciireadTWO2 2 _ r asciiwrite"
asciireadTWO2 3 _ r asciiwrite#
asciireadTWO2 4 _ r asciiwrite$
asciireadTWO2 5 _ r asciiwrite%
